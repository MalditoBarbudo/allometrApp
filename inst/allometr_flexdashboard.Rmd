---
title: "Allometr App"
output: 
  flexdashboard::flex_dashboard:
    vertical_layout: fill
runtime:
  shiny
params:
  appdb_user: "guest"
  appdb_password: "guest"
  appdb_dbname: "allometr_db"
  appdb_host: "localhost"
---

```{r global, include=FALSE}
# libraries
library(flexdashboard)
library(tidyverse)
library(shiny)
library(shinyjs)
library(plotly)
library(writexl)
library(DT)
library(allometrApp)
```

```{r data}
# database
allometr_db <- pool::dbPool(
  RPostgreSQL::PostgreSQL(),
  user = params$appdb_user,
  password = params$appdb_password,
  dbname = params$appdb_dbname,
  host = params$appdb_host
)

# tables
allometries_table <- dplyr::tbl(allometr_db, 'ALLOMETRIES') %>% dplyr::collect()
variables_thesaurus <- dplyr::tbl(allometr_db, 'THESAURUS_VARIABLES') %>% dplyr::collect()
cubication_thesaurus <- dplyr::tbl(allometr_db, 'THESAURUS_CUBICATION') %>%
  dplyr::collect()

## on stop routine to cloose the db pool
# shiny::onStop(function() {
  pool::poolClose(allometr_db)
# })
```


Sidebar {.sidebar}
=====================================

#### Especify the desired constraints for the allometries:

```{r}
## NOTFIX better input logic for autodetect available values

# shinyjs
useShinyjs(rmd = TRUE)

# shiny inputs defined here
# choices
allometry_choices <- allometries_table %>%
  dplyr::pull(allometry_level) %>%
  unique() %>% sort()
spatial_choices <- allometries_table %>%
  dplyr::pull(spatial_level) %>%
  unique() %>% sort()
functgroup_choices <- allometries_table %>%
  dplyr::pull(functional_group_level) %>%
  unique() %>% sort()
depvar_choices <- variables_thesaurus %>%
  dplyr::filter(var_dependent) %>%
  dplyr::pull(var_id) %>%
  magrittr::set_names(
    variables_thesaurus %>%
      dplyr::filter(var_dependent) %>%
      dplyr::pull(translation_eng)
  )
indepvars_choices <- variables_thesaurus %>%
  dplyr::filter(var_independent) %>%
  dplyr::pull(var_id) %>%
  magrittr::set_names(
    variables_thesaurus %>%
      dplyr::filter(var_independent) %>%
      dplyr::pull(translation_eng)
  )
cubication_choices <- cubication_thesaurus %>%
  dplyr::pull(cubication_shape_id) %>%
  c('any', .) #%>%
  # magrittr::set_names(
  #   cubication_thesaurus %>%
  #     dplyr::pull(translation_eng) %>%
  #     c('Any', .)
  # )
specialparam_choices <- allometries_table %>%
  dplyr::pull(special_param) %>% unique() %>% sort()
# inputs
shiny::tagList(
  shiny::div(
    id = 'inputs_sidebar',
    # vars
    shiny::selectInput(
      'depvar', 'Dependent variable',
      choices = depvar_choices, multiple = TRUE
    ),
    shiny::selectInput(
      'indepvars', 'Independent variables',
      choices = indepvars_choices, multiple = TRUE
    ),
    # allometry
    shiny::selectInput(
      'allolvl', 'Allometry level',
      choices = allometry_choices, multiple = TRUE
    ),
    shinyjs::hidden(
      shiny::uiOutput('allo_values')
    ),
    # spatial
    shiny::selectInput(
      'spatial', 'Spatial ambit', choices = spatial_choices, multiple = TRUE
    ),
    shinyjs::hidden(
      shiny::uiOutput('spatial_values')
    ),
    # functional group
    shiny::selectInput(
      'functgroup', 'Functional group', choices = functgroup_choices,
      multiple = TRUE
    ),
    shinyjs::hidden(
      shiny::div(
        id = 'functgroup_values_div',
        shiny::uiOutput('functgroup_values')
      )
    ),
    # other
    shiny::selectInput(
      'cubication', 'Cubication shape', choices = cubication_choices,
      multiple = TRUE
    ),
    shiny::selectInput(
      'specialparam', 'Special parameter',
      choices = specialparam_choices, multiple = TRUE
    ),
    shiny::br(),
    
    # reset button
    shiny::actionButton('reset_all', 'Reset')
    )
)
```


```{r, context="server"}
# reactive to create the filtering expressions
filtering_expr <- shiny::reactive({
  # filter exprs
  rlang::quos(
    allometry_level %in% !! input$allolvl,
    spatial_level %in% !! input$spatial,
    spatial_name %in% !! input$spatial_values_input,
    functional_group_level %in% !! input$functgroup,
    functional_group_name %in% !! input$functgroup_values_input,
    dependent_var %in% !! input$depvar,
    independent_var_1 %in% !! input$indepvars |
      independent_var_2 %in% !! input$indepvars |
      independent_var_3 %in% !! input$indepvars,
    cubication_shape %in% !! input$cubication,
    special_param %in% !! input$specialparam
  ) %>%
    # removing null or empty inputs
    magrittr::extract(!purrr::map_lgl(list(
      input$allolvl,
      input$spatial,
      input$spatial_values_input,
      input$functgroup,
      input$functgroup_values_input,
      input$depvar,
      input$indepvars,
      input$cubication,
      input$specialparam
    ), is.null))
})

# observer to show the ui for the allometry level values
shiny::observe({
  allometry_level <- input$allolvl
  if (is.null(allometry_level) || allometry_level == '') {
    shinyjs::hide('allo_values')
  } else {
    shinyjs::show('allo_values')
  }
})
# observer to show the ui for spatial values
shiny::observe({
  spatial <- input$spatial
  if (is.null(spatial) || spatial == '') {
    shinyjs::hide('spatial_values')
  } else {
    shinyjs::show('spatial_values')
  }
})
output$spatial_values <- shiny::renderUI({
  # spatial level
  spatial_vals <- input$spatial
  # choices
  spatial_values_choices <- allometries_table %>%
    dplyr::filter(spatial_level %in% spatial_vals) %>%
    dplyr::pull(spatial_name) %>% unique() %>% sort()
  # UI
  shiny::tagList(
    shiny::selectInput(
      'spatial_values_input', 'Select the spatial ambit values',
      choices = spatial_values_choices, multiple = TRUE
    )
  )
})
# observer to show the ui for functional group values
shiny::observe({
  functional_group <- input$functgroup
  if (is.null(functional_group) || functional_group == '') {
    shinyjs::hide('functgroup_values_div')
  } else {
    shinyjs::show('functgroup_values_div')
  }
})
output$functgroup_values <- shiny::renderUI({
  # functgroup level
  functgroup_vals <- input$functgroup
  # choices
  functgroup_values_choices <- allometries_table %>%
    dplyr::filter(functional_group_level %in% functgroup_vals) %>%
    dplyr::pull(functional_group_name) %>% unique() %>% sort()
  # UI
  shiny::tagList(
    shiny::selectInput(
      'functgroup_values_input', 'Select the functional group values',
      choices = functgroup_values_choices, multiple = TRUE
    )
  )
})

# observer for reset button
shiny::observeEvent(
  input$reset_all,
  {
    shinyjs::reset('inputs_sidebar')
  }
)
```

Table {data-orientation=rows}
=====================================

Row
-------------------------------------

### Table
    
```{r table_ui}
# table output
# div(
#   style = 'overflow-x: scroll',
  DTOutput('allometr_table')
# )
```

```{r table_output, context="server"}
output$allometr_table <- renderDT({
  allometries_table %>%
    dplyr::filter(!!! filtering_expr()) %>%
    dplyr::mutate_if(is.numeric, round, 3) %>%
    datatable(
      class = 'compact hover nowrap row-border order-column',
      extensions = 'Scroller',
      options = list(
        dom = 'tr',
        # pageLength = 10,
        # lengthMenu = c(10, 25, 50),
        deferRender = TRUE,
        scrollY = '600px', scroller = TRUE, scrollX = TRUE
      )
    )
})
```

Row {data-height=50}
-------------------------------------

### Download allometries table

```{r save_table}
fluidRow(
  column(2, offset = 4, downloadLink('save_csv', 'Download as a csv file')),
  column(2, downloadLink('save_xlsx', 'Download as a xlsx file'))
)
```

```{r save_table_output, context="server"}
output$save_csv <- downloadHandler(
  filename = function() {
    paste("allometries_", Sys.Date(), '.csv', sep = '')
  },
  content = function(file) {
    
    data_res <- allometries_table %>%
    dplyr::filter(!!! filtering_expr())
    
    write_csv(data_res, file)
  }
)

output$save_xlsx <- downloadHandler(
  filename = function() {
    paste("allometries_", Sys.Date(), '.xlsx', sep = '')
  },
  content = function(file) {
    
    data_res <- allometries_table %>%
    dplyr::filter(!!! filtering_expr())
    
    write_xlsx(data_res, file)
  }
)
```

Calculate
=====================================

Column {data-width=150}
-------------------------------------

### 

#### Data input

Please, select a file to load with the data to be converted. Accepted formats are
**csv** and **xlsx**. Both of them must have a **header** with columns names

```{r data_input}
shiny::fileInput(
  'user_data', NULL, FALSE,
  accept = c(
    '.csv', '.xlsx', 'text/csv', 'text/comma-separated-values,text/plain',
    'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    buttonLabel = 'Browse...', placeholder = 'No file selected...'
  )
)

user_data <- reactive({
  
  if (is.null(input$user_data)) {
    return(NULL)
  }
  
  extension <- input$user_data$name %>%
    stringr::str_extract('\\.[a-zA-Z]{3,4}$')
  if (extension == '.csv') {
    res <- readr::read_csv(input$user_data$datapath)
  } else {
    res <- readxl::read_excel(input$user_data$datapath)
  }
  
  # shiny::validate(
  #   shiny::need(ncol(res) > 0 , 'No numeric columns detected in the data provided')
  # )
})
```

#### Select the allometry

Select the allometry to use. If in doubt check the [allometry table](#table)

```{r allometry_selector}
selectInput(
  'allometry_selector', NULL, choices = '', size = 5, selectize = FALSE
)

observe({
  id_choices <- allometries_table %>%
    dplyr::filter(!!! filtering_expr()) %>%
    dplyr::pull(allometry_id)
  
  updateSelectInput(
    session, 'allometry_selector', NULL, id_choices
  )
})
```


#### Variables declaration

Select the variables from the uploaded data corresponding to the independent variables
from the equation:

```{r}
uiOutput('var_declaration')

output$var_declaration <- renderUI({
  
  shiny::validate(
    shiny::need(user_data(), 'No user data provided'),
    shiny::need(input$allometry_selector, 'No user data provided')
  )
  
  allom_id <- input$allometry_selector
  allom_desc <- allom_description(id = allom_id)
  
  independent_vars <- c(
    allom_desc[[allom_id]][['independent_var_1']],
    allom_desc[[allom_id]][['independent_var_2']],
    allom_desc[[allom_id]][['independent_var_3']]
  ) %>%
    purrr::discard(function(x) {is.na(x)})
  
  lapply(independent_vars, function(x) {
    varSelectInput(
      glue::glue("{x}_input"),
      glue::glue("Variable acting as {x}"),
      # x,
      data = user_data() %>% dplyr::select_if(is.numeric),
      selectize = FALSE, size = 5
    )
  })
})

allom_variables_exprs <- reactive({
  
  allom_id <- input$allometry_selector
  allom_desc <- allom_description(id = allom_id)
  
  independent_vars <- c(
    allom_desc[[allom_id]][['independent_var_1']],
    allom_desc[[allom_id]][['independent_var_2']],
    allom_desc[[allom_id]][['independent_var_3']]
  ) %>%
    purrr::discard(function(x) {is.na(x)})
  
  # TODO convert to Dn = Dn expressions
  independent_vars %>%
    purrr::walk(
      ~ shiny::validate(
          shiny::need(input[[paste0(.x, '_input')]], 'No variable declaration')
        )
    ) %>%
    purrr::map_chr(
      ~ glue::glue("{.x} = {input[[paste0(.x, '_input')]]},")
    ) %>%
    stringr::str_c(collapse = ' ')
    
})
```


Column {data-width=400}
-------------------------------------

### Result table

```{r}
calculated_data <- reactive({
  shiny::validate(
    shiny::need(user_data(), 'No user data provided'),
    shiny::need(input$allometry_selector, 'No user data provided')
    
    # shiny::need(
    #   !is.character(user_data()[['']])
    # )
  )
  
  shiny::validate(
    shiny::need(allom_variables_exprs(), 'No variables declaration provided'),
    shiny::need(length(allom_variables_exprs()) > 0, 'No variables declaration provided')
  )
  
  # let's try to do it with glue + parse_exprs because it will be easier I think
  glue::glue(
    "user_data() %>%
    allom_calculate(
      {paste0(allom_variables_exprs(), sep = ' ')}
      allometry_id = '{input$allometry_selector}',
      name = '{allom_description(id = input$allometry_selector)[[input$allometry_selector]]$dependent_var}'
    )"
  ) %>%
    rlang::parse_expr() %>%
    eval()
})


renderTable({
  calculated_data()
})
```

### Download results {data-height=50}

```{r calculated_table}
fluidRow(
  column(2, offset = 4, downloadLink('calculate_csv', 'Download as a csv file')),
  column(2, downloadLink('calculate_xlsx', 'Download as a xlsx file'))
)
```

```{r calculated_table_output, context="server"}
output$calculate_csv <- downloadHandler(
  filename = function() {
    paste("calculated_allometry", Sys.Date(), '.csv', sep = '')
  },
  content = function(file) {
    
    data_res <- calculated_data()
    
    write_csv(data_res, file)
  }
)

output$calculate_xlsx <- downloadHandler(
  filename = function() {
    paste("calculated_allometry", Sys.Date(), '.xlsx', sep = '')
  },
  content = function(file) {
    
    data_res <- calculated_data()
    
    write_xlsx(data_res, file)
  }
)
```
